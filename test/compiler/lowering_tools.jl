using Core: SSAValue
using Base: remove_linenums!

# Call into lowering stage 1; syntax desugaring
function fl_expand_forms(ex)
    ccall(:jl_call_scm_on_ast_formonly, Any, (Cstring, Any, Any), "jl-expand-forms", ex, Main)
end

include("../../base/compiler/lowering/desugar.jl")

# Make it easy to swap fl_expand_forms with the julia version.
if !isdefined(@__MODULE__, :use_flisp)
    use_flisp = true
end
function _expand_forms(ex)
    if use_flisp
        fl_expand_forms(ex)
    else
        try
            expand_forms(ex)
        catch exc
            exc isa LoweringError || rethrow()
            # Hack: show only msg for more compatibility with flisp error forms
            return Expr(:error, exc.msg)
            #return Expr(:error, sprint(show, exc))
        end
    end
end

function lift_lowered_expr!(ex, nextids, valmap, lift_full)
    if ex isa SSAValue
        # Rename SSAValues into renumbered symbols
        return get!(valmap, ex) do
            newid = nextids[1]
            nextids[1] = newid+1
            Symbol("ssa$newid")
        end
    end
    if ex isa Symbol
        if ex == Symbol("#self#")
            return :_self_
        end
        # Rename gensyms
        name = string(ex)
        if startswith(name, "#")
            return get!(valmap, ex) do
                newid = nextids[2]
                nextids[2] = newid+1
                Symbol("gsym$newid")
            end
        end
    end
    if ex isa Expr
        if ex.head == :block && length(ex.args) == 1
            # Remove trivial blocks
            return lift_lowered_expr!(ex.args[1], nextids, valmap, lift_full)
        end
        map!(ex.args, ex.args) do e
            lift_lowered_expr!(e, nextids, valmap, lift_full)
        end
        if lift_full
            # Lift exotic Expr heads into standard julia syntax for ease in
            # writing test case expressions.
            if ex.head == :top || ex.head == :core
                # Special global refs renamed to look like modules
                newhead = ex.head == :top ? :Top : :Core
                return Expr(:(.), newhead, QuoteNode(ex.args[1]))
            elseif ex.head == :unnecessary
                # `unnecessary` marks expressions generated by lowering that
                # do not need to be evaluated if their value is unused.
                return Expr(:call, :maybe_unused, ex.args...)
                #=
            elseif ex.head in [:_while, :_do_while, :scope_block, :break_block,
                               :break, :local_def, :require_existing_local]
                return Expr(:macrocall, Symbol("@Expr"), nothing,
                            QuoteNode(ex.head), ex.args...)
                            =#
            end
        end
    elseif ex isa Vector # Occasional case of lambdas
        map!(ex, ex) do e
            lift_lowered_expr!(e, nextids, valmap, lift_full)
        end
    end
    return ex
end

"""
Clean up an `Expr` into an equivalent form which can be easily entered by
hand

* Replacing `SSAValue(id)` with consecutively numbered symbols :ssa\$i
* Remove trivial blocks
"""
function lift_lowered_expr(ex; lift_full=false)
    valmap = Dict{Union{Symbol,SSAValue},Symbol}()
    lift_lowered_expr!(remove_linenums!(deepcopy(ex)), ones(Int,2), valmap, lift_full)
end

"""
Very slight lowering of reference expressions to allow comparison with
desugared forms.

* Remove trivial blocks
* Translate psuedo-module expressions Top.x and Core.x to Expr(:top) and
  Expr(:core)
"""
function lower_ref_expr!(ex)
    if ex isa Expr
        map!(lower_ref_expr!, ex.args, ex.args)
        if ex.head == :block && length(ex.args) == 1
            # Remove trivial blocks
            return lower_ref_expr!(ex.args[1])
        end
        # Translate a selection of special expressions into the exotic Expr
        # heads used in lowered code.
        if ex.head == :(.) && length(ex.args) >= 1 && (ex.args[1] == :Top ||
                                                       ex.args[1] == :Core)
            if !(length(ex.args) == 2 && ex.args[2] isa QuoteNode)
                throw("Unexpected top/core expression $(sprint(dump, ex))")
            end
            return Expr(ex.args[1] == :Top ? :top : :core, ex.args[2].value)
        elseif ex.head == :call && length(ex.args) >= 1 && ex.args[1] == :maybe_unused
            return Expr(:unnecessary, ex.args[2:end]...)
        elseif ex.head == :macrocall && ex.args[1] == Symbol("@Expr")
            head = ex.args[3]
            head isa QuoteNode || throw(ArgumentError("`head` argument to @Expr should be quoted"))
            return Expr(head.value, ex.args[4:end]...)
        end
    end
    return ex
end
lower_ref_expr(ex) = lower_ref_expr!(remove_linenums!(deepcopy(ex)))


function diffdump(io::IOContext, ex1, ex2, n, prefix, indent)
    if ex1 == ex2
        isempty(prefix) || print(io, prefix)
        dump(io, ex1, 2, indent)
    else
        if ex1 isa Expr && ex2 isa Expr && ex1.head == ex2.head && length(ex1.args) == length(ex2.args)
            isempty(prefix) || print(io, prefix)
            println(io, "Expr")
            println(io, indent, "  head: ", ex1.head)
            println(io, indent, "  args: Array{Any}(", size(ex1.args), ")")
            for i in 1:length(ex1.args)
                prefix = string(indent, "    ", i, ": ")
                diffdump(io, ex1.args[i], ex2.args[i], 4, prefix, string("    ", indent))
                i < length(ex1.args) && println(io)
            end
        else
            printstyled(io, string(prefix, sprint(dump, ex1, 4, indent; context=io)), color=:green)
            println()
            printstyled(io, string(prefix, sprint(dump, ex2, 4, indent; context=io)), color=:red)
        end
    end
end

"""
Display colored differences between two expressions `ex1` and `ex2` using the
`dump` format.
"""
function diffdump(ex1, ex2; maxdepth=20)
    mod = get(stdout, :module, Main)
    diffdump(IOContext(stdout, :limit => true, :module => mod), ex1, ex2, maxdepth, "", "")
    println(stdout)
end

# For interactive convenience in constructing test cases with flisp based lowering
function desugar(ex; lift=:full)
    expanded = _expand_forms(ex)
    if lift == :full || lift == :partial
        lift_lowered_expr(expanded; lift_full=(lift == :full))
    else
        expanded
    end
end

# Macro for producing exotic `Expr`s found in lowered ASTs
#
# Note that this is provided for convenience/reference but in practice we
# expand it "manually" inside lower_ref_expr!
macro Expr(head, args...)
    head isa QuoteNode || throw(ArgumentError("`head` argument to @Expr should be quoted"))
    esc(Expr(head.value, args...))
end

"""
    @desugar ex [kws...]

Convenience macro, equivalent to `desugar(:(ex), kws...)`.
"""
macro desugar(ex, kws...)
    quote
        desugar($(Expr(:quote, ex)); $(map(esc, kws)...))
    end
end

# Convenience macro to print code for a test case
macro maketest(ex)
    Base.remove_linenums!(ex)
    quote
        print($(QuoteNode(ex)), "\n")
        print(desugar($(Expr(:quote, ex))), "\n")
    end
end

"""
    @testset_desugar(name, exprs)

Test that a set of expressions lower correctly to desugared AST form. This
creates a new `@testset` with the given `name`. The statements in the block
`exprs` are interpreted as a flat list of any number of `input_expr`,
`ref_expr` pairs, where `input_expr` should be transformed by lowering into
`ref_expr` by the desugaring pass.  For example,

```
@testset_desugar "Property notation" begin
    # flisp: (expand-fuse-broadcast)
    a.b
    Top.getproperty(a, :b)

    a.b.c
    Top.getproperty(Top.getproperty(a, :b), :c)
end
```
"""
macro testset_desugar(name, block)
    if !(block isa Expr && block.head == :block)
        throw(ArgumentError("@testset_desugar requires a block as the second argument"))
    end
    loc = nothing
    tests = []
    i = 1
    while i <= length(block.args)
        if block.args[i] isa LineNumberNode
            loc = block.args[i]
            i += 1
            continue
        end
        exs = []
        while i <= length(block.args) && length(exs) < 2
            if !(block.args[i] isa LineNumberNode)
                push!(exs, block.args[i])
            end
            i += 1
        end
        if length(exs) == 0
            break
        end
        if length(exs) == 1
            throw(ArgumentError("List of expressions to @testset_desugar must consist of input,ref pairs"))
        end
        input = exs[1]
        ref = exs[2]
        ex = quote
            expanded = lift_lowered_expr(_expand_forms($(Expr(:quote, input))))
            reference = lower_ref_expr($(Expr(:quote, ref)))
            @test expanded == reference
            if expanded != reference
                # Kinda crude. Would be much neater if Test supported custom/more
                # capable diffing for failed tests.
                println("Diff dump:")
                diffdump(expanded, reference)
            end
        end
        # Attribute the test to the correct line number
        @assert ex.args[6].args[1] == Symbol("@test")
        ex.args[6].args[2] = loc
        push!(tests, ex)
    end
    quote
        @testset $name begin
            $(tests...)
        end
    end
end
